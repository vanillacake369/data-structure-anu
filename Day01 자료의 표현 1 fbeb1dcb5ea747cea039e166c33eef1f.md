# Day01 자료의 표현 1

# Contents

# 자료의 표현

## binary

### 정의

숫자 문자 그림 소리 등등을 2진수 코드인 binary로 표현 및 저장해야 컴퓨터가 인식 가능하다.

0과 1로서 참과 거짓의 조합을 표현한다

<aside>
💡 1 word 
→ 한 번에 읽을 수 있는 bit 수. 운영체제에 따라 크기가 다르다.

메인메모리에서 데이터를 인식하는 버스 구조가 있는데 운영체제 별로 다르기 때문이다.
컴퓨터의 구조가 다르기 때문에 컴파일 혹은 인터프리트 할 때 구조를 따져가며 코딩을 해야한다.

</aside>

### 수의 범위

n개의 비트로 2^n개의 상태 표현 가능

개수는 2^n-1개

## 자료의 종류

- 수치
    - 10진수
        - 존 형식
        - 팩 형식
    - 2진수
        - 정수
            - 부호절대
            - 1의보수
            - 2의보수
        - 실수
            - 고정소수
            - 부동소수
- 문자
- 논리
- 포인터
- 문자열

# 10진수

## 존 형식

1바이트 사용

- 상위 4비트 : 1111로 표현 (구분자 역할)
- 하위 4비트 : 10진수 한 자리 값에 대해 2진수 값을 표시 
→ 16진수(4bit 단위로 읽어 bin으로 변환)
- 마지막 자리의 존영역에 부호를 표시

1111  숫자 1111 숫자 .... 마지막 하위 비트 1100(+)/1101(-) 숫자

## 팩 형식

존영역(1111 구분자) 없이 4비트를 사용

최하위 4비트에 부호를 표시

숫자 숫자 숫자 .... 숫자 1100(+)/1101(-)

# 이진수

## 정수

### 부호절댓값 표현

- 최상위 1비트 부호 표시
- 나머지 n-1 비트 : 이진수 표시

Ex) 1바이트 부호 절대 표현

0(+) 0010101(21) → +21

### 1의 보수

기존 부호절대에서 0→1/1→0 을 사용

<aside>
💡 하지만 여전히 +0과 –0이 존재하는 논리적 오류를 가지고 있습니다. 그리고 덧셈, 뺄셈연산 은 간단해졌지만 캐리가 발생했을때 추가로 연산을 해주어야하는 문제가 남아있습니다.

이때문에 캐리 가 발생했을때 LSB에 1을 더해주는 것 을 고려하여 회로를 구성해야합니다.
**1의 보수 방식을 이용한 뺄셈 예제를 다루어보겠습니다**

ex) 5-4
8비트 2진수로, 10진수 5를 표현하면 0000 0101 이고
4를 표현하면 0000 0100 입니다.
4를 1의 보수방식을 이용해 음수화해야하므로, MSB를 1로 설정하고 남은 부분을 1,0을 반전시킵니다
따라서 0000 0100 ==> 1111 1011 을 얻을수 있습니다.
0000 0101 ( +5)
1111 1011 ( - 4)
===============
**1** 0000  0000 ( =1 )

캐리가 발생했으므로 캐리를 버리고, 추가로 LSB(최하위비트에 1을 더해줍니다).

</aside>

### 2의 보수

1의 보수에 1을 더함

<aside>
💡 1의 보수에서 캐리가 발생했을 때 LSB에 1을 다시 더해주어야하므로 한번의 연산을 하기 위해 두번의 연산을 해야한다
Ex. 5 + (-4) = 1 0000 0000 이므로 0이 아닌 1을 표현하기위해 LSB에 +1해주어야 함

반면,
2의 보수에서 는 캐리가 발생했을때 캐리를 무시하므로 단 한번의 덧셈으로 연산이 가능합니다.

즉, 오버플로우 처리가 2의보수가 훨씬 간단하다.

</aside>

## 실수 표현

### 고정 소수점

소수점이 항상 최상위 비트의 왼쪽 밖에 고정되어있는 것으로 취급

000101 의 표현은 0.00101의 값인 것이다.

### 부동 소수점

**정규화 표현**

213 = 0.213 x 10^3 

부호부 / 지수부 / 가수부 로 나눈다.

# 문자

## BCD 코드

6비트를 사용하여 문자표현

상위 2비트 : 존표현

하위 4비트 : 2진수 비트

[https://t1.daumcdn.net/cfile/tistory/266FD1415659E48D1E](https://t1.daumcdn.net/cfile/tistory/266FD1415659E48D1E)

![Untitled](Day01%20%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%8B%E1%85%B4%20%E1%84%91%E1%85%AD%E1%84%92%E1%85%A7%E1%86%AB%201%20fbeb1dcb5ea747cea039e166c33eef1f/Untitled.png)

[https://t1.daumcdn.net/cfile/tistory/216584455659E4863F](https://t1.daumcdn.net/cfile/tistory/216584455659E4863F)

## EBCDIC 코드

8비트를 사용하여 문자 표현

상위 4비트 : 존표현

하위 4비트 : 2진수 비트

[https://t1.daumcdn.net/cfile/tistory/21416B425659E4BA0F](https://t1.daumcdn.net/cfile/tistory/21416B425659E4BA0F)

[EBCDIC 코드표]

[https://t1.daumcdn.net/cfile/tistory/2238A3425659E4DD11](https://t1.daumcdn.net/cfile/tistory/2238A3425659E4DD11)

## ASCII 코드

7비트를 사용하여 문자 표현

상위 3비트 : 존표현

하위 4비트 : 2진수 비트

[https://t1.daumcdn.net/cfile/tistory/243F683D5659E4F211](https://t1.daumcdn.net/cfile/tistory/243F683D5659E4F211)

[ASCII 코드표]

행은 숫자 비트, 열은 존 비트

[https://t1.daumcdn.net/cfile/tistory/2230FA3D5659E5BA15](https://t1.daumcdn.net/cfile/tistory/2230FA3D5659E5BA15)

## 유니코드

여러 나라 언어를 통일하기 위해 국제 표준 코드(ISO/IEC 10646)

# 논리자료의 표현

## 논리자료란

논리값을 표현하기 위한 자료형식

- 논리값이란?
참,거짓 → 1/0
- 1바이트를 사용하여 논리자료 표현
1.  참 : 최하위 비트를 1, 거짓 : 전체비트를 0

2.  참: 전체 비트 1, 거짓 : 전체비트 0으로 

3.  참 : 하나 이상의 비트를 1, 거짓: 전체비트를 0으로

# 포인터 자료

메모리 주소를 표현하기 위한 자료 형식

# 문자열 자료

1. 구분자를 사용 `;`
대부분의 컴퓨터언어에서 `;` 을 통해 문자열을 구분하기로 명세
    
    
    → `;`라는 구분자의 메모리 또한 생성해야함..
    
    → 구분자 식별시간으로 탐색.
    
2. 고정 길이의 문자열을 사용
10크기의 고정길이를 통해 각 문자열을 구분
    
    
    → 메모리 낭비가 심함.
    
    → 탐색 시에는 고정길이 별로 탐색하면 되므로 빠름.
    
3. 포인터를 사용
    
    각 문자열의 시작 주소를 HEAD배열에 저장
    
    Ex) 
    Computer의 C시작주소 → HEAD[0]
    Data Structure의 D 시작주소 → HEAD[1]
    String의 S 시작주소 → HEAD[2]
    
    → 메모리 이용이 효율적
    
    → 탐색 시에는 포인터만 참조하더라도 값을 직접 참조,비교를 해야 알 수 있으므로 구분자 사용보다는 효율적이지 못 함
    
    → 복잡도 측면에서는 포인터 구조를 생성해야하므로 제일 안 좋음
    

# Reference

- **[어셈블리어] 정수의 음수표현과 캐리 & 오버플로우 - (carry and overflow)**

[https://man-25-1.tistory.com/60](https://man-25-1.tistory.com/60)

- BCD 코드

[https://soofi.tistory.com/46](https://soofi.tistory.com/46)

- BCD, EBCDIC, ASCII

[https://itdexter.tistory.com/58](https://itdexter.tistory.com/58)